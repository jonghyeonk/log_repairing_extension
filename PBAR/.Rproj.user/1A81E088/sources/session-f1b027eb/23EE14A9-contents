{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import tensorflow as tf\n",
    "import pm4py\n",
    "from pm4py.objects.conversion.log import converter as log_converter\n",
    "from pm4py.algo.discovery.inductive import algorithm as inductive_miner\n",
    "from pm4py.algo.conformance.alignments.petri_net import algorithm\n",
    "import pandas as pd\n",
    "import numpy\n",
    "import datetime\n",
    "from pm4py.util import exec_utils\n",
    "import pkgutil\n",
    "from pm4py.algo.conformance.alignments.edit_distance import algorithm as logs_alignments\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "c:\\Users\\whd1g\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pm4py\\utils.py:486: UserWarning: the EventLog class has been deprecated and will be removed in a future release.\n",
      "  warnings.warn(\"the EventLog class has been deprecated and will be removed in a future release.\")\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "83a978e18a4b471abb62329553e6a51c",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "aligning log, completed variants ::   0%|          | 0/4631 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[1;32mc:\\Users\\whd1g\\OneDrive\\바탕 화면\\볼차노\\PBAR_extension\\alignment\\test2.ipynb Cell 2\u001b[0m in \u001b[0;36m<cell line: 9>\u001b[1;34m()\u001b[0m\n\u001b[0;32m     <a href='vscode-notebook-cell:/c%3A/Users/whd1g/OneDrive/%EB%B0%94%ED%83%95%20%ED%99%94%EB%A9%B4/%EB%B3%BC%EC%B0%A8%EB%85%B8/PBAR_extension/alignment/test2.ipynb#W1sZmlsZQ%3D%3D?line=40'>41</a>\u001b[0m start\u001b[39m=\u001b[39m datetime\u001b[39m.\u001b[39mdatetime\u001b[39m.\u001b[39mnow()\n\u001b[0;32m     <a href='vscode-notebook-cell:/c%3A/Users/whd1g/OneDrive/%EB%B0%94%ED%83%95%20%ED%99%94%EB%A9%B4/%EB%B3%BC%EC%B0%A8%EB%85%B8/PBAR_extension/alignment/test2.ipynb#W1sZmlsZQ%3D%3D?line=41'>42</a>\u001b[0m net, initial_marking, final_marking \u001b[39m=\u001b[39m pm4py\u001b[39m.\u001b[39mdiscover_petri_net_inductive(log)\n\u001b[1;32m---> <a href='vscode-notebook-cell:/c%3A/Users/whd1g/OneDrive/%EB%B0%94%ED%83%95%20%ED%99%94%EB%A9%B4/%EB%B3%BC%EC%B0%A8%EB%85%B8/PBAR_extension/alignment/test2.ipynb#W1sZmlsZQ%3D%3D?line=43'>44</a>\u001b[0m alignments \u001b[39m=\u001b[39m algorithm\u001b[39m.\u001b[39;49mapply_log(log2, net, initial_marking, final_marking)\n\u001b[0;32m     <a href='vscode-notebook-cell:/c%3A/Users/whd1g/OneDrive/%EB%B0%94%ED%83%95%20%ED%99%94%EB%A9%B4/%EB%B3%BC%EC%B0%A8%EB%85%B8/PBAR_extension/alignment/test2.ipynb#W1sZmlsZQ%3D%3D?line=46'>47</a>\u001b[0m end\u001b[39m=\u001b[39m datetime\u001b[39m.\u001b[39mdatetime\u001b[39m.\u001b[39mnow()\n\u001b[0;32m     <a href='vscode-notebook-cell:/c%3A/Users/whd1g/OneDrive/%EB%B0%94%ED%83%95%20%ED%99%94%EB%A9%B4/%EB%B3%BC%EC%B0%A8%EB%85%B8/PBAR_extension/alignment/test2.ipynb#W1sZmlsZQ%3D%3D?line=48'>49</a>\u001b[0m \u001b[39mif\u001b[39;00m r \u001b[39m==\u001b[39m \u001b[39m'\u001b[39m\u001b[39m1.00\u001b[39m\u001b[39m'\u001b[39m:\n",
      "File \u001b[1;32mc:\\Users\\whd1g\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pm4py\\algo\\conformance\\alignments\\petri_net\\algorithm.py:216\u001b[0m, in \u001b[0;36mapply_log\u001b[1;34m(log, petri_net, initial_marking, final_marking, parameters, variant)\u001b[0m\n\u001b[0;32m    214\u001b[0m this_max_align_time \u001b[39m=\u001b[39m \u001b[39mmin\u001b[39m(max_align_time_case, (max_align_time \u001b[39m-\u001b[39m (time\u001b[39m.\u001b[39mtime() \u001b[39m-\u001b[39m start_time)) \u001b[39m*\u001b[39m \u001b[39m0.5\u001b[39m)\n\u001b[0;32m    215\u001b[0m parameters[Parameters\u001b[39m.\u001b[39mPARAM_MAX_ALIGN_TIME_TRACE] \u001b[39m=\u001b[39m this_max_align_time\n\u001b[1;32m--> 216\u001b[0m all_alignments\u001b[39m.\u001b[39mappend(apply_trace(trace, petri_net, initial_marking, final_marking, parameters\u001b[39m=\u001b[39;49mcopy(parameters),\n\u001b[0;32m    217\u001b[0m                                   variant\u001b[39m=\u001b[39;49mvariant))\n\u001b[0;32m    218\u001b[0m \u001b[39mif\u001b[39;00m progress \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n\u001b[0;32m    219\u001b[0m     progress\u001b[39m.\u001b[39mupdate()\n",
      "File \u001b[1;32mc:\\Users\\whd1g\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pm4py\\algo\\conformance\\alignments\\petri_net\\algorithm.py:131\u001b[0m, in \u001b[0;36mapply_trace\u001b[1;34m(trace, petri_net, initial_marking, final_marking, parameters, variant)\u001b[0m\n\u001b[0;32m    127\u001b[0m parameters \u001b[39m=\u001b[39m copy(parameters)\n\u001b[0;32m    128\u001b[0m best_worst_cost \u001b[39m=\u001b[39m exec_utils\u001b[39m.\u001b[39mget_param_value(Parameters\u001b[39m.\u001b[39mBEST_WORST_COST_INTERNAL, parameters,\n\u001b[0;32m    129\u001b[0m                                              __get_best_worst_cost(petri_net, initial_marking, final_marking, variant, parameters))\n\u001b[1;32m--> 131\u001b[0m ali \u001b[39m=\u001b[39m exec_utils\u001b[39m.\u001b[39;49mget_variant(variant)\u001b[39m.\u001b[39;49mapply(trace, petri_net, initial_marking, final_marking,\n\u001b[0;32m    132\u001b[0m                                              parameters\u001b[39m=\u001b[39;49mparameters)\n\u001b[0;32m    134\u001b[0m trace_cost_function \u001b[39m=\u001b[39m exec_utils\u001b[39m.\u001b[39mget_param_value(Parameters\u001b[39m.\u001b[39mPARAM_TRACE_COST_FUNCTION, parameters, [])\n\u001b[0;32m    135\u001b[0m \u001b[39m# Instead of using the length of the trace, use the sum of the trace cost function\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Users\\whd1g\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pm4py\\algo\\conformance\\alignments\\petri_net\\variants\\state_equation_a_star.py:169\u001b[0m, in \u001b[0;36mapply\u001b[1;34m(trace, petri_net, initial_marking, final_marking, parameters)\u001b[0m\n\u001b[0;32m    163\u001b[0m \u001b[39melse\u001b[39;00m:\n\u001b[0;32m    164\u001b[0m     trace_net, trace_im, trace_fm, parameters[\n\u001b[0;32m    165\u001b[0m         Parameters\u001b[39m.\u001b[39mPARAM_TRACE_NET_COSTS] \u001b[39m=\u001b[39m trace_net_cost_aware_constr_function(trace,\n\u001b[0;32m    166\u001b[0m                                                                                  trace_cost_function,\n\u001b[0;32m    167\u001b[0m                                                                                  activity_key\u001b[39m=\u001b[39mactivity_key)\n\u001b[1;32m--> 169\u001b[0m alignment \u001b[39m=\u001b[39m apply_trace_net(petri_net, initial_marking, final_marking, trace_net, trace_im, trace_fm, parameters)\n\u001b[0;32m    171\u001b[0m \u001b[39mreturn\u001b[39;00m alignment\n",
      "File \u001b[1;32mc:\\Users\\whd1g\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pm4py\\algo\\conformance\\alignments\\petri_net\\variants\\state_equation_a_star.py:380\u001b[0m, in \u001b[0;36mapply_trace_net\u001b[1;34m(petri_net, initial_marking, final_marking, trace_net, trace_im, trace_fm, parameters)\u001b[0m\n\u001b[0;32m    373\u001b[0m     sync_prod, sync_initial_marking, sync_final_marking, cost_function \u001b[39m=\u001b[39m construct_cost_aware(\n\u001b[0;32m    374\u001b[0m         trace_net, trace_im, trace_fm, petri_net, initial_marking, final_marking, utils\u001b[39m.\u001b[39mSKIP,\n\u001b[0;32m    375\u001b[0m         trace_net_costs, model_cost_function, revised_sync)\n\u001b[0;32m    377\u001b[0m max_align_time_trace \u001b[39m=\u001b[39m exec_utils\u001b[39m.\u001b[39mget_param_value(Parameters\u001b[39m.\u001b[39mPARAM_MAX_ALIGN_TIME_TRACE, parameters,\n\u001b[0;32m    378\u001b[0m                                                   sys\u001b[39m.\u001b[39mmaxsize)\n\u001b[1;32m--> 380\u001b[0m alignment \u001b[39m=\u001b[39m apply_sync_prod(sync_prod, sync_initial_marking, sync_final_marking, cost_function,\n\u001b[0;32m    381\u001b[0m                        utils\u001b[39m.\u001b[39;49mSKIP, ret_tuple_as_trans_desc\u001b[39m=\u001b[39;49mret_tuple_as_trans_desc,\n\u001b[0;32m    382\u001b[0m                        max_align_time_trace\u001b[39m=\u001b[39;49mmax_align_time_trace)\n\u001b[0;32m    384\u001b[0m return_sync_cost \u001b[39m=\u001b[39m exec_utils\u001b[39m.\u001b[39mget_param_value(Parameters\u001b[39m.\u001b[39mRETURN_SYNC_COST_FUNCTION, parameters, \u001b[39mFalse\u001b[39;00m)\n\u001b[0;32m    385\u001b[0m \u001b[39mif\u001b[39;00m return_sync_cost:\n\u001b[0;32m    386\u001b[0m     \u001b[39m# needed for the decomposed alignments (switching them from state_equation_less_memory)\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Users\\whd1g\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pm4py\\algo\\conformance\\alignments\\petri_net\\variants\\state_equation_a_star.py:410\u001b[0m, in \u001b[0;36mapply_sync_prod\u001b[1;34m(sync_prod, initial_marking, final_marking, cost_function, skip, ret_tuple_as_trans_desc, max_align_time_trace)\u001b[0m\n\u001b[0;32m    392\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39mapply_sync_prod\u001b[39m(sync_prod, initial_marking, final_marking, cost_function, skip, ret_tuple_as_trans_desc\u001b[39m=\u001b[39m\u001b[39mFalse\u001b[39;00m,\n\u001b[0;32m    393\u001b[0m                     max_align_time_trace\u001b[39m=\u001b[39msys\u001b[39m.\u001b[39mmaxsize):\n\u001b[0;32m    394\u001b[0m     \u001b[39m\"\"\"\u001b[39;00m\n\u001b[0;32m    395\u001b[0m \u001b[39m    Performs the basic alignment search on top of the synchronous product net, given a cost function and skip-symbol\u001b[39;00m\n\u001b[0;32m    396\u001b[0m \n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m    408\u001b[0m \u001b[39m    and **traversed_arcs**\u001b[39;00m\n\u001b[0;32m    409\u001b[0m \u001b[39m    \"\"\"\u001b[39;00m\n\u001b[1;32m--> 410\u001b[0m     \u001b[39mreturn\u001b[39;00m __search(sync_prod, initial_marking, final_marking, cost_function, skip,\n\u001b[0;32m    411\u001b[0m                     ret_tuple_as_trans_desc\u001b[39m=\u001b[39;49mret_tuple_as_trans_desc, max_align_time_trace\u001b[39m=\u001b[39;49mmax_align_time_trace)\n",
      "File \u001b[1;32mc:\\Users\\whd1g\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pm4py\\algo\\conformance\\alignments\\petri_net\\variants\\state_equation_a_star.py:523\u001b[0m, in \u001b[0;36m__search\u001b[1;34m(sync_net, ini, fin, cost_function, skip, ret_tuple_as_trans_desc, max_align_time_trace)\u001b[0m\n\u001b[0;32m    520\u001b[0m traversed \u001b[39m+\u001b[39m\u001b[39m=\u001b[39m \u001b[39m1\u001b[39m\n\u001b[0;32m    521\u001b[0m new_marking \u001b[39m=\u001b[39m utils\u001b[39m.\u001b[39madd_markings(current_marking, t\u001b[39m.\u001b[39madd_marking)\n\u001b[1;32m--> 523\u001b[0m \u001b[39mif\u001b[39;00m new_marking \u001b[39min\u001b[39;49;00m closed:\n\u001b[0;32m    524\u001b[0m     \u001b[39mcontinue\u001b[39;00m\n\u001b[0;32m    525\u001b[0m g \u001b[39m=\u001b[39m curr\u001b[39m.\u001b[39mg \u001b[39m+\u001b[39m cost\n",
      "File \u001b[1;32mc:\\Users\\whd1g\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pm4py\\objects\\petri_net\\obj.py:32\u001b[0m, in \u001b[0;36mMarking.__eq__\u001b[1;34m(self, other)\u001b[0m\n\u001b[0;32m     31\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39m__eq__\u001b[39m(\u001b[39mself\u001b[39m, other):\n\u001b[1;32m---> 32\u001b[0m     \u001b[39mif\u001b[39;00m \u001b[39mnot\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39mkeys() \u001b[39m==\u001b[39m other\u001b[39m.\u001b[39;49mkeys():\n\u001b[0;32m     33\u001b[0m         \u001b[39mreturn\u001b[39;00m \u001b[39mFalse\u001b[39;00m\n\u001b[0;32m     34\u001b[0m     \u001b[39mfor\u001b[39;00m p \u001b[39min\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39mkeys():\n",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "\n",
    "datas = ['Small', 'Medium', 'Large', 'Huge', 'Wide', 'credit-card', 'mccloud',\n",
    "         'hospital_billing', 'Road_Traffic', 'b12', 'b17'] \n",
    "\n",
    "datas = ['b12', 'b17'] \n",
    "# rate = ['0.10', '0.25', '0.50', '1.00'] # change\n",
    "rate = ['1.00']\n",
    "cost = list()\n",
    "\n",
    "for data in datas:\n",
    "    for r in rate:\n",
    "    ##\n",
    "        before = pd.read_csv(\"~\\\\OneDrive\\\\바탕 화면\\\\볼차노\\\\PBAR_extension\\\\alignment\\\\encoded_normal\\\\\" + data + \".csv\")\n",
    "        after = pd.read_csv(\"~\\\\OneDrive\\\\바탕 화면\\\\볼차노\\\\PBAR_extension\\\\alignment\\\\encoded_anomaly\\\\\" + data + \"_\"+ r + \".csv\")\n",
    "    ##\n",
    "        before = before[['Case', 'Activity', \"Complete.Timestamp\", \"Event\"]]\n",
    "        before = before.rename(columns={\"Case\": \"case:concept:name\", \"Activity\": \"concept:name\",\n",
    "                            \"Complete.Timestamp\": \"time:timestamp\", \"Event\": \"Resource\"})\n",
    "        after = after[['Case', 'Activity', \"Timestamp\", \"type_res_trace\"]]\n",
    "        after = after.rename(columns={\"Case\": \"case:concept:name\", \"Activity\": \"concept:name\",\n",
    "                            \"Timestamp\": \"time:timestamp\", \"type_res_trace\": \"label\"})\n",
    "\n",
    "        clean = after[after.label.isnull() ]\n",
    "        # anomaly = after[~after.label.isnull() ]\n",
    "        clean = clean.reset_index(drop=True)\n",
    "        # anomaly = anomaly.reset_index(drop=True)\n",
    "        anomaly = after.reset_index(drop=True)\n",
    "        \n",
    "        \n",
    "        clean = clean[[\"case:concept:name\", \"concept:name\",\"time:timestamp\" ]]\n",
    "        anomaly = anomaly[[\"case:concept:name\", \"concept:name\",\"time:timestamp\" ]]\n",
    "\n",
    "        correct_align = before[before[\"case:concept:name\"].isin( anomaly[\"case:concept:name\"].unique()) ]\n",
    "        correct_align = correct_align[[\"case:concept:name\", \"concept:name\",\"time:timestamp\" ]]\n",
    "\n",
    "        anomalyid = anomaly[\"case:concept:name\"].unique()\n",
    "\n",
    "        log = log_converter.apply(clean)\n",
    "        log2 = log_converter.apply(anomaly)\n",
    "\n",
    "\n",
    "        start= datetime.datetime.now()\n",
    "        net, initial_marking, final_marking = pm4py.discover_petri_net_inductive(log)\n",
    "\n",
    "        alignments = algorithm.apply_log(log2, net, initial_marking, final_marking)\n",
    "\n",
    "\n",
    "        end= datetime.datetime.now()\n",
    "        \n",
    "        if r == '1.00':\n",
    "            cost.append(float((end-start).total_seconds())/60)\n",
    "        cases = anomaly['case:concept:name'].unique()\n",
    "        length = len(cases)\n",
    "        w=0\n",
    "        case_l = list()\n",
    "        case2_l = list()\n",
    "        act3_l = list()\n",
    "\n",
    "        score=0\n",
    "        for i in alignments:\n",
    "            if i is None:\n",
    "                print(\"None!!\")\n",
    "                #print(w)\n",
    "\n",
    "\n",
    "            else:\n",
    "                act_l = list()\n",
    "                act2_l = list()\n",
    "                org = correct_align[correct_align[\"case:concept:name\"].isin([anomalyid[w]])]\n",
    "                act_org = org[\"concept:name\"].values.tolist()\n",
    "                caseid = anomalyid[w]\n",
    "                for k in i['alignment']:\n",
    "                    if (k[1] != None) and (k[1] != '>>'):\n",
    "                        act2_l.append(k[1])\n",
    "                        case2_l.append(caseid)\n",
    "                        act3_l.append(k[1])\n",
    "                    if k[0] != '>>':\n",
    "                        act_l.append(k[0])\n",
    "                        case_l.append(caseid)\n",
    "                w = w + 1\n",
    "                if act_org != act2_l:\n",
    "                    score = score + 1\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "        d = {'Case':case2_l,'Activity':act3_l}\n",
    "        df = pd.DataFrame(d)\n",
    "\n",
    "        # print(1-score/length)\n",
    "        os.chdir(\"C:\\\\Users\\\\whd1g\\\\OneDrive\\\\바탕 화면\\\\볼차노\\\\PBAR_extension\\\\alignment\\\\result_trd\")\n",
    "        df.to_csv(data+ \"_\" + r + \".csv\", index= False)\n",
    "        \n",
    "\n",
    "\n",
    "\n",
    "    for r in rate:\n",
    "    ##\n",
    "        before = pd.read_csv(\"~\\\\OneDrive\\\\바탕 화면\\\\볼차노\\\\PBAR_extension\\\\alignment\\\\encoded_normal\\\\\" + data + \".csv\")\n",
    "        after = pd.read_csv(\"~\\\\OneDrive\\\\바탕 화면\\\\볼차노\\\\PBAR_extension\\\\alignment\\\\encoded_anomaly\\\\\" + data + \"_\"+ r + \".csv\")\n",
    "\n",
    "    ##\n",
    "        before = before[['Case', 'Activity', \"Complete.Timestamp\", \"Event\"]]\n",
    "        before = before.rename(columns={\"Case\": \"case:concept:name\", \"Activity\": \"concept:name\",\n",
    "                            \"Complete.Timestamp\": \"time:timestamp\", \"Event\": \"Resource\"})\n",
    "        after = after[['Case', 'Activity', \"Timestamp\", \"type_res_trace\"]]\n",
    "        after = after.rename(columns={\"Case\": \"case:concept:name\", \"Activity\": \"concept:name\",\n",
    "                            \"Timestamp\": \"time:timestamp\", \"type_res_trace\": \"label\"})\n",
    "\n",
    "        \n",
    "        clean = after[after.label.isnull() ]\n",
    "        # anomaly = after[~after.label.isnull() ]\n",
    "        clean = clean.reset_index(drop=True)\n",
    "        # anomaly = anomaly.reset_index(drop=True)\n",
    "        anomaly = after.reset_index(drop=True)\n",
    "\n",
    "        clean = clean[[\"case:concept:name\", \"concept:name\",\"time:timestamp\" ]]\n",
    "        anomaly = anomaly[[\"case:concept:name\", \"concept:name\",\"time:timestamp\" ]]\n",
    "\n",
    "        correct_align = before[before[\"case:concept:name\"].isin( anomaly[\"case:concept:name\"].unique()) ]\n",
    "        correct_align = correct_align[[\"case:concept:name\", \"concept:name\",\"time:timestamp\" ]]\n",
    "\n",
    "        anomalyid = anomaly[\"case:concept:name\"].unique()\n",
    "\n",
    "        log = log_converter.apply(clean)\n",
    "        log2 = log_converter.apply(anomaly)\n",
    "\n",
    "\n",
    "        start= datetime.datetime.now()\n",
    "        parameters = {}\n",
    "        alignments = logs_alignments.apply(log2, log, parameters=parameters)\n",
    "        end= datetime.datetime.now()\n",
    "        \n",
    "        if r == '1.00':\n",
    "            cost.append(float((end-start).total_seconds())/60)\n",
    "\n",
    "        cases = anomaly['case:concept:name'].unique()\n",
    "        length = len(cases)\n",
    "        w=0\n",
    "        case_l = list()\n",
    "        case2_l = list()\n",
    "        act3_l = list()\n",
    "\n",
    "        score=0\n",
    "        for i in alignments:\n",
    "            if i is None:\n",
    "                print(\"None!!\")\n",
    "                #print(w)\n",
    "\n",
    "\n",
    "            else:\n",
    "                act_l = list()\n",
    "                act2_l = list()\n",
    "                org = correct_align[correct_align[\"case:concept:name\"].isin([anomalyid[w]])]\n",
    "                act_org = org[\"concept:name\"].values.tolist()\n",
    "                caseid = anomalyid[w]\n",
    "                for k in i['alignment']:\n",
    "                    if (k[1] != None) and (k[1] != '>>'):\n",
    "                        act2_l.append(k[1])\n",
    "                        case2_l.append(caseid)\n",
    "                        act3_l.append(k[1])\n",
    "                    if k[0] != '>>':\n",
    "                        act_l.append(k[0])\n",
    "                        case_l.append(caseid)\n",
    "                w = w + 1\n",
    "                if act_org != act2_l:\n",
    "                    score = score + 1\n",
    "\n",
    "\n",
    "\n",
    "        print(cost)\n",
    "        d = {'Case':case2_l,'Activity':act3_l}\n",
    "        df = pd.DataFrame(d)\n",
    "\n",
    "        # print(1-score/length)\n",
    "        os.chdir(\"C:\\\\Users\\\\whd1g\\\\OneDrive\\\\바탕 화면\\\\볼차노\\\\PBAR_extension\\\\alignment\\\\result_edit\")\n",
    "        df.to_csv(data+ \"_\" + r + \".csv\", index= False)\n",
    "    \n",
    "    \n",
    "print(cost)\n",
    "print(cost)\n",
    "print(cost)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[91.30721696666666, 0.06011938333333333]\n"
     ]
    }
   ],
   "source": [
    "print(cost)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.5"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
